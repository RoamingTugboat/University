Aufgabe 1
	Schreiben Sie eine Lösung für den kurzen Test aus der letzten Veranstaltung.
	
		# Systemnahe Programmierung - Testen Sie Ihre Kenntnisse!
		# H. Hoegl, 2012-11-08 

		#   timespow(3, 2) + timespow(2, 3)

			.section .data
			.section .text
			.globl _start

		_start:
			pushl $2        # b
			pushl $3        # x
			call  timespow2
			addl  $8, %esp  
			pushl %eax      
			pushl $3        # b    
			pushl $2        # x
			call  timespow2
			addl  $8, %esp  
			popl  %ebx      
			addl %eax, %ebx 
			movl $1, %eax   
			int $0x80


		# timespow2(x, b)
		#   return x * 2^b
		#   Trick: x * 2^b = shift argument x left by b bits 
		#                    shll %cl, %ebx  (shift ebx left by cl bits)
		.type timespow2, @function
		timespow2:
			push %ebp             # 1 Prolog
			movl %esp, %ebp       # 2 Prolog
			movl 12(%ebp), %ecx	  # 3 Argument holen 
			movl 8(%ebp), %ebx	  # 4 Argument holen
			shll %cl, %ebx		  # 5 Schieben
			movl %ebx, %eax		  # 6 Ergebnis ablegen
			movl %ebp, %esp		  # 7 Epilog
			popl %ebp			  # 8 Epilog
			ret					  # 9 Zurueckkehren
			
			
Aufgabe 2

	Vollziehen Sie das im Kapitel 5 (Bartlett) beschriebene Programm mit dem Debugger gdb nach.
	
	
	
Aufgabe 3

	Formulieren Sie das Programm aus Kapitel 5 in den Sprachen:
	
		
    C:
	
		?
		
	
    Java:
	
		public void toUpperCase() {
			BufferedReader br = new BufferedReader(new FileReader("sourcefile.txt"));
			BufferedWriter bw = new BufferedWriter(new FileWriter("zielfile.txt"))
			
			String inputString = ""
			while(inputString = br.nextLine() != "") {
				bw.write(inputString.toUpperCase());
			}
			
			br.close();
			bw.close();
			
		}
		
	
    Python:
	
		def toUpperCase():
			source = open('sourcefile.txt', 'r')
			ziel = open('zielfile.txt', 'w')
			for line in source:
				ziel.write(line.upper())
			

			
Aufgabe 4

	Bearbeiten Sie die Aufgaben.
	
		Know the Concepts:
		
			• Describe the lifecycle of a file descriptor.
				File descriptors are generated by the kernel(?). This happens after the system call "open" has been executed.
				The exact nature of the FD depends on the state of the registers eax, ebx, ecx and edx when the system call happens.
			
			• What are the standard file descriptors and what are they used for?
				STDIN, STDOUT, STDERR. IN and OUT are used as interfaces for Keyboard->System and System->Screen Display communications, ERR logs errors that
				occur on the way to STDOUT.
				
			• What is a buffer?
				A space in memory that data is passed through. The data will most likely be read by a program as it's passing through.
			
			• What is the difference between the .data section and the .bss section?
				Variables in the data section must have values assigned to them, variables in the bss section just reserve memory space without having actual
				values.
			
			• What are the system calls related to reading and writing files?
				
				The OPEN system call with the following register contents: 
				
					Read:					
						eax	- $5
						ebx - Starting byte of file
						ecx - $0 (= "read")
						edx - $0666 (permissions)

						
					Write:
						eax	- $5
						ebx - Starting byte of file
						ecx - $03101 (= "write")
						edx - $0666 (permissions)
							
					both these calls will return file descriptors. Those will be used for the
					read and write system calls.
					
					
					
		Use the Concepts:
		
			• Modify the toupper program so that it reads from STDIN and writes to STDOUT instead of using the files on the command-line.
				
				Delete open_df_in and open_fd_out.
				
				Replace store_fd_in with:
					movl $0, ST_FD_IN(%ebp)
					
				and store_fd_out with:
					movl $1, ST_FD_OUT(%ebp)
					
					
			• Change the size of the buffer.
			
				Change the integer in: 
					.equ BUFFER_SIZE 500
				
				to any other value lower than 16000.
			
			
			• Rewrite the program so that it uses storage in the .bss section rather than the stack to store the file descriptors.

				Remove the two variables from the .data section.
				
				Add:
					.lcomm ST_FD_IN 32
					.lcomm ST_FD_OUT 32
				to the .bss section.
				
				Change store_fd_in and store_fd_out to move the value from %eax into the respective .bss variables.
				
				Replace all occurences of ST_FD_IN(%ebp) and ST_FD_OUT(%ebp) with $ST_FD_IN and $ST_FD_OUT in order to use the variables instead of accessing the stack.
				
			
			• Write a program that will create a file called heynow.txt and write the words	"Hey diddle diddle!" into it.
				
				.section .data
					.globl _start

					TARGET_FILE: .asciz "heynow.txt"
					TEXT: .asciz "Hey diddle diddle!"
					.equ SYSC, 0x80

				.section .bss
					.lcomm FD_IN, 32
					.lcomm FD_OUT, 32

				.section .text

				_start:
				 #OPEN target file to get its file descriptor
				 movl $5, %eax            #open
				 movl $TARGET_FILE, %ebx  #at this memory location
				 movl $03101, %ecx        #in order to write
				 movl $0666, %edx         #with full permission
				 int $SYSC              #Execute the OPEN command. The file descriptor of the target file will be returned in %eax.
				 
				 #Save the file descriptor to the address FD_IN.
				 movl %eax, FD_IN       


				 #Write text to target file
				 movl $4, %eax            #write
				 movl FD_IN, %ebx         #to this file
				 movl $TEXT, %ecx         #content from this address
				 movl $18, %edx           #the content is 18 bytes long
				 int $SYSC              #execute Write


				 #CLOSE target file
				 movl $6, %eax
				 movl FD_IN, %ebx
				 int $SYSC

				 #exit with error code 0
				 movl $1, %eax
				 movl $0, %ebx
				 int $SYSC